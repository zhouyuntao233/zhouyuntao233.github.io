[{"title":"Java数据库","url":"/2021/03/13/Java数据库/","content":"\n### 数据库索引\n\n1. 索引分类：普通索引，唯一索引，全文索引，空间索引\n2. 存储方式：B-Tree ,Hash\n\n#### 最左匹配原则\n\n还是这个图好理解\n\n![image-20210313091354021](https://cdn.jsdelivr.net/gh/zhouyuntao233/Picture_Bed/img/image-20210313091354021.png)\n\n##### MySQL的索引为什么用B+树\n\n>B+ 树是**多路查找平衡树**的一种\n\n由B树和索引顺序访问方法演化而来，它是为磁盘或其他直接存取辅助设备设计的一种平衡查找树，在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点，各叶子节点通过指针进行链接。如下图：\n\n![img](https://static.nowcoder.com/images/activity/2021jxy/java/img/btree-1.jpg)\n\nB+树索引在数据库中的一个特点就是高扇出性，例如在InnoDB存储引擎中，每个页的大小为16KB。在数据库中，B+树的高度一般都在2～4层，这意味着查找某一键值最多只需要2到4次IO操作，这还不错。因为现在一般的磁盘每秒至少可以做100次IO操作，2～4次的IO操作意味着查询时间只需0.02～0.04秒。\n\n\n\n#### 数据库事务","tags":["Java数据库"],"categories":["语言基础"]},{"title":"Java项目","url":"/2021/03/11/Java项目/","content":"\n记录一下项目中的零碎知识点\n\n<!--more--> \n\n### Spring IOC和AOP\n\n\n**IOC** :就是将对象交给容器管理，要用的时候再向容器要就行了\n\n常用注解：\n\n**Controller层：** @Controller\n\n**Service层:** @Service\n\n**Dao层：** @Repository  （如果使用MyBatis的话 ，一般还要加上注解 @Mapper）\n\n其实这三个层 都可以用@Compoment  只是名字不同罢了\n\n**AOP**: 面向切面编程 通俗的讲就是 **代理**\n\n![image-20210311162022364](https://cdn.jsdelivr.net/gh/zhouyuntao233/Picture_Bed/img/image-20210311162022364.png)\n\n\n\n### cookie 和 session\n\n![image-20210311104114290](https://cdn.jsdelivr.net/gh/zhouyuntao233/Picture_Bed/img/image-20210311104114290.png)\n\n#### \n\n\n\n","tags":["Java"],"categories":["工程项目"]},{"title":"Java多线程","url":"/2021/03/10/Java多线程/","content":"\n<!--more--> \n\n\n\n![image-20210310141647100](https://cdn.jsdelivr.net/gh/zhouyuntao233/Picture_Bed/img/image-20210310141647100.png)","tags":["Java多线程"],"categories":["语言基础"]},{"title":"Java基础","url":"/2021/03/10/Java基础/","content":"\n## Java基础\n\n<!--more--> \n\n### 为什么Java代码可以实现一次编写、到处运行？\n\nJVM（Java虚拟机）是Java跨平台的关键。\n\n在程序运行前，Java源代码（.java）需要经过编译器编译成字节码（.class）。在程序运行时，JVM负责将字节码翻译成特定平台下的机器码并运行，也就是说，只要在不同的平台上安装对应的JVM，就可以运行字节码文件。\n\n同一份Java源代码在不同的平台上运行，它不需要做任何的改变，并且只需要编译一次。而编译好的字节码，是通过JVM这个中间的“桥梁”实现跨平台的，JVM是与平台相关的软件，它能将统一的字节码翻译成该平台的机器码。\n\n### Java 访问权限\n\nJava语言为我们提供了三种访问修饰符，即private、protected、public，在使用这些修饰符修饰目标时，一共可以形成四种访问权限，即private、defalut、protected、public，注意在不加任何修饰符时为default访问权限。\n\n在修饰成员变量/成员方法时，该成员的四种访问权限的含义如下：\n\n- private：该成员可以被该类内部成员访问；\n- defalut：该成员可以被该类内部成员访问，也可以被同一包下其他的类访问；\n- protected：该成员可以被该类内部成员访问，也可以被同一包下其他的类访问，还可以被它的子类访问；\n- public：该成员可以被任意包下，任意类的成员进行访问。\n\n在修饰类时，该类只有两种访问权限，对应的访问权限的含义如下：\n\n- defalut：该类可以被同一包下其他的类访问；\n- public：该类可以被任意包下，任意的类所访问。\n\n###  Java 数据类型\n\nJava数据类型包括基本数据类型和引用数据类型两大类。\n\n基本数据类型有8个，可以分为4个小类，分别是整数类型（byte/short/int/long）、浮点类型（float/double）、字符类型（char）、布尔类型（boolean）。其中，4个整数类型中，int类型最为常用。2个浮点类型中，double最为常用。另外，在这8个基本类型当中，除了布尔类型之外的其他7个类型，都可以看做是数字类型，它们相互之间可以进行类型转换。\n\n引用类型就是对一个对象的引用，根据引用对象类型的不同，可以将引用类型分为3类，即数组、类、接口类型。引用类型本质上就是通过指针，指向堆中对象所持有的内存空间，只是Java语言不再沿用指针这个说法而已。\n\n**扩展阅读**\n\n对于基本数据类型，你需要了解每种类型所占据的内存空间，面试官可能会追问这类问题：\n\n- **byte：1字节（8位），数据范围是 `-2^7 ~ 2^7-1`**\n- **short：2字节（16位），数据范围是 `-2^15 ~ 2^15-1`**\n- **int：4字节（32位），数据范围是 `-2^31 ~ 2^31-1`**\n- **long：8字节（64位），数据范围是 `-2^63 ~ 2^63-1`**\n- **float：4字节（32位），数据范围大约是 `-3.4*10^38 ~ 3.4*10^38`**\n- **double：8字节（64位），数据范围大约是 `-1.8*10^308 ~ 1.8*10^308`**\n- **char：2字节（16位），数据范围是 `\\u0000 ~ \\uffff`**\n- **boolean：Java规范没有明确的规定，不同的JVM有不同的实现机制。**\n\n对于引用数据类型，你需要了解JVM的内存分布情况，知道引用以及引用对象存放的位置，详见JVM部分的题目。\n\n#### int和Integer有什么区别，二者在做==运算时会得到什么结果\n\nint是基本数据类型，Integer是int的包装类。二者在做==运算时，Integer会自动拆箱为int类型，然后再进行比较。届时，如果两个int值相等则返回true，否则就返回false。\n\n\n\n\n\n### 全局变量和局部变量的区别\n\nJava中的变量分为成员变量和局部变量，它们的区别如下：\n\n成员变量：\n\n1. 成员变量是在类的范围里定义的变量；\n2. 成员变量有默认初始值；\n3. 未被static修饰的成员变量也叫实例变量，它存储于对象所在的堆内存中，生命周期与对象相同；\n4. 被static修饰的成员变量也叫类变量，它存储于方法区中，生命周期与当前类相同。\n\n局部变量：\n\n1. 局部变量是在方法里定义的变量；\n2. 局部变量没有默认初始值；\n3. 局部变量存储于栈内存中，作用的范围结束，变量空间会自动的释放。\n\n**注意事项**\n\nJava中没有真正的全局变量，面试官应该是出于其他语言的习惯说全局变量的，他的本意应该是指成员变量。\n\n\n\n### 面向对象的理解\n\n面向对象是一种更优秀的程序设计方法，它的基本思想是使用类、对象、继承、封装、消息等基本概念进行程序设计。它从现实世界中客观存在的事物出发来构造软件系统，并在系统构造中尽可能运用人类的自然思维方式，强调直接以现实世界中的事物为中心来思考，认识问题，并根据这些事物的本质特点，把它们抽象地表示为系统中的类，作为系统的基本构成单元，这使得软件系统的组件可以直接映像到客观世界，并保持客观世界中事物及其相互关系的本来面貌。\n\n**扩展阅读**\n\n结构化程序设计方法主张按功能来分析系统需求，其主要原则可概括为自顶向下、逐步求精、模块化等。结构化程序设计首先采用结构化分析方法对系统进行需求分析，然后使用结构化设计方法对系统进行概要设计、详细设计，最后采用结构化编程方法来实现系统。\n\n因为结构化程序设计方法主张按功能把软件系统逐步细分，因此这种方法也被称为面向功能的程序设计方法；结构化程序设计的每个功能都负责对数据进行一次处理，每个功能都接受一些数据，处理完后输出一些数据，这种处理方式也被称为面向数据流的处理方式。\n\n结构化程序设计里最小的程序单元是函数，每个函数都负责完成一个功能，用以接收一些输入数据，函数对这些输入数据进行处理，处理结束后输出一些数据。整个软件系统由一个个函数组成，其中作为程序入口的函数被称为主函数，主函数依次调用其他普通函数，普通函数之间依次调用，从而完成整个软件系统的功能。\n\n每个函数都是具有输入、输出的子系统，函数的输入数据包括函数形参、全局变量和常量等，函数的输出数据包括函数返回值以及传出参数等。结构化程序设计方式有如下两个局限性：\n\n- 设计不够直观，与人类习惯思维不一致。采用结构化程序分析、设计时，开发者需要将客观世界模型分解成一个个功能，每个功能用以完成一定的数据处理。\n- 适应性差，可扩展性不强。由于结构化设计采用自顶向下的设计方式，所以当用户的需求发生改变，或需要修改现有的实现方式时，都需要自顶向下地修改模块结构，这种方式的维护成本相当高\n\n#### 面向对象的三大特征\n\n面向对象的程序设计方法具有三个基本特征：**封装、继承、多态**。\n\n封装指的是将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能；\n\n继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法；\n\n多态指的是子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，这意味着同一个类型的对象在执行同一个方法时，可能表现出多种行为特征。\n\n","tags":["Java"],"categories":["语言基础"]},{"title":"myBatis配置","url":"/2021/03/09/myBatis配置/","content":"\n简单记录一下Mybatis配置\n<!--more--> \n\n工程整体目录\n\n![image-20210309112754802](https://cdn.jsdelivr.net/gh/zhouyuntao233/Picture_Bed/img/image-20210309112754802.png)\n\n### 导入Maven包\n\n```xml\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>8.0.23</version>\n</dependency>\n\n<dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis</artifactId>\n    <version>3.5.6</version>\n</dependency>\n```\n\n\n\n### 配置myBatis\n\n在resoures目录下，新建mybatis的配置文件 例如myBatisConfig.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://81.70.192.71:3306/db\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"123zhou\"/>\n            </dataSource>\n        </environment>\n    </environments>\n    <mappers>\n        <mapper resource=\"com/cloud/dao/userMapper.xml\"/>   \n    </mappers>\n</configuration>\n```\n\n\n\n![image-20210309111727795](https://cdn.jsdelivr.net/gh/zhouyuntao233/Picture_Bed/img/image-20210309111727795.png)\n\n\n\n#### 配置接口创建配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.cloud.dao.userDao\">\n    <select id=\"getUserList\" resultType=\"com.cloud.pojo.User\">\n        select * from student\n    </select>\n</mapper>\n```\n\n![image-20210309112245593](https://cdn.jsdelivr.net/gh/zhouyuntao233/Picture_Bed/img/image-20210309112245593.png)\n\n\n\n#### 创建工具配置类\n\nmyBatisConfig.java\n\n```java\npackage com.cloud.utils;\n\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class mybatisConfig {\n    private static SqlSessionFactory sqlSessionFactory;\n    static {\n        try {\n            String resource = \"mybatisConfig.xml\"; //加载配置文件\n            InputStream inputStream = Resources.getResourceAsStream(resource);\n            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    // 获取会话\n    public static SqlSession getSqlsession(){\n        SqlSession sqlSession=sqlSessionFactory.openSession();\n        return  sqlSession;\n    }\n\n}\n```\n\n\n\n#### 测试\n\n使用junit测试\n\n```java\npublic class UserDaoTest {\n\n    @Test\n    public void test01(){\n        SqlSession sqlSession= mybatisConfig.getSqlsession();\n        userDao userdao= sqlSession.getMapper(userDao.class);\n\n        List<User> result=userdao.getUserList();\n        for(User user:result){\n            System.out.println(user);\n        }\n        sqlSession.close();\n    }\n}\n```\n\n\n\n可能会报错，通常是找不到资源文件\n\n需要在pom.xml文件中,添加以下内容\n\n```xml\n    <build>\n        <resources>\n            <resource>\n                <directory>src/main/java</directory>\n                <includes>\n                    <include>**/*.properties</include>\n                    <include>**/*.xml</include>\n                </includes>\n                <filtering>false</filtering>\n            </resource>\n            <resource>\n                <directory>src/main/resources</directory>\n                <includes>\n                    <include>**/*.properties</include>\n                    <include>**/*.xml</include>\n                </includes>\n                <filtering>false</filtering>\n            </resource>\n        </resources>\n    </build>\n```\n\n\n\n\n\n#### 整合Spring boot\n\n![image-20210309141607561](https://cdn.jsdelivr.net/gh/zhouyuntao233/Picture_Bed/img/image-20210309141607561.png)\n\n\n\n\n\n对于SpringBoot的application.properties\n\n##### 配置springboot的数据源\n\n\n\n```properties\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\nspring.datasource.url=jdbc:mysql://81.70.192.71:3306/db\nspring.datasource.username=root\nspring.datasource.password=123zhou\nspring.datasource.type=com.alibaba.druid.pool.DruidDataSource\n\nmybatis.mapper-locations=classpath:mybatis/*.xml\n```\n\n![image-20210309160830629](https://cdn.jsdelivr.net/gh/zhouyuntao233/Picture_Bed/img/image-20210309160830629.png)\n\n\n\n再resource目录下创建mybatis的配置（映射）文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.cloud.mapper.UserMapper\">\n    <select id=\"getUser\" resultType=\"com.cloud.pojo.User\">\n        select * from student\n    </select>\n</mapper>\n```\n\n","tags":["Mybatis"],"categories":["工具配置"]},{"title":"刷题相关","url":"/2021/02/20/刷题相关/","content":"\n**记录一下刷题知识**\n\n其实也知道程序=算法+数据结构，但就是缺乏恒心练下去，走一步看一步\n\n<!--more--> \n\n### 数学\n\n#### 最大公约数\n\n```c++\nint a,b;\ncin>>a>>b;\nwhile(b!=0){\n    int tmp=a%b;\n    a=b;\n    b=tmp;\n}\ncout<<a;\n```\n\n\n\n### 字符串\n\n```c++\n#include<string>\n\n// 常用api\nstring s;\ns.size();/s.length()  // 返回大小\ns.substr(i,j)  // 从i开始长度为j的字符串\n\n\n```\n\n\n\n### 位运算\n\n#### 移位\n\n```c++\na = 01111011;     // 循环左移2位的正确结果是： b=11101101\nb = a >> (8 - 2); //用来得到正常左移丢失的位和循环移位后其正确位置　　//b=00000001；\na = a << 2;　　    //a = 11101100\na = a | b;　　     //a = 11101101\n\n如果不是用中间变量 a=（a>>（8-2））|（a<<2）\n    \n通用：\n总长度N（8 16 32）\n循环左移n (a >> (N - n)) | (a >> n)\n循环右移n (a << (N - n)) | (a >> n)\n```\n\n\n\n \n\n### 查找\n\n```c++\nint my_search(int arr[],int n,int k){\n    for(int i=0;i<n;i++){\n        if(arr[i]==k) return i;\n    }\n    return -1;  \n}\n```\n\n","tags":["技巧"],"categories":["算法"]},{"title":"树莓派音频助手","url":"/2021/02/18/树莓派音频助手/","content":"\n**简单记录一下配置树莓派语音助手**\n\n<!--more--> \n\n### 录音配置\n\n[参考链接](https://blog.csdn.net/toopoo/article/details/109408978)\n\n#### 安装sox及其mp3库\n\n```shell\nsudo apt-get install sox libsox-fmt-mp3\n```\n\n如果需要支持所有可用音频格式那么应该这样安装:\n\n```shell\nsudo apt-get install libsox-fmt-all\n```\n\n#### 录音和播放\n\n如果USB声卡已经设置为默认声卡，那么最简单的方法就是\n\n```shell\nrec test.mp3\nplay test.mp3\n```\n\n也可以指定录音和播放设备：\n\n```shell\nsox -t alsa plughw:1,0 test.mp3\n```\n\n`plughw:1,0`是USB声卡设备编号，可以通过如下命令查看\n\n```shell\narecord -l\n#或者\naplay -l\n#或者\ncat /proc/asound/cards\n```\n\n也可以通过如下python脚本获取\n\n```python\nimport pyaudio\np = pyaudio.PyAudio()\nfor ii in range(p.get_device_count()):\n\tprint(p.get_device_info_by_index(ii).get('name'))\n```\n\n##### 将编号为1的USB声卡设置为默认的方法(Pi 4B测试通过)\n\n- 方法1\n  编辑`~/.asoundrc`\n  输入以下内容\n\n```shell\ndefaults.ctl.card 1\ndefaults.pcm.card 1\n```\n\n- 方法2\n  在user profile中加入\n\n```shell\nexport AUDIODEV=hw:1,0\n```\n\n> Note:我没用这个方法sox也默认使用了USB声卡作为录音和回放设备,可能与我安装了pulseaudio有关。卸载pulseaudio之后就需要指定USB声卡了。\n\n##### 测试声卡(编号1)：\n\n```shell\nspeaker-test -D plughw:1 -c2 -t wav\n```\n\n##### 录制固定长度的音频片段（如 30 分钟）并保存在指定文件中：\n\n```shell\nsox -t alsa plughw:1 myrec.wav trim 0 00:30:00\n```\n\n##### 持续录制很长时间的音频，保存在几个不同的文件中，每隔一小时保存一次：\n\n```shell\nsox -t alsa plughw:1 myrec.wav trim 0 01:00:00 : newfile : restart\n```\n\n##### 使用arecord指定设备(-D plughw:1,0)双声道录音(-c 2)并指定长度(-d 5)和采样率(-r 44100)\n\n```shell\narecord -D plughw:1,0 -d 5 -c 2 -r 44100 -f s16_LE helloworld.wav\n```\n\n如果sox或者rec命令运行时遇到如下提示：\n\n```shell\nrec WARN alsa: can't encode 0-bit Unknown or not applicable\n```\n\n可以运行如下命令解决:\n\n```shell\nexport AUDIODRIVER=alsa\n```\n\n\n### 语音唤醒\n\n#### snowboy 语音唤醒\n\n[snowboy唤醒词制作](https://github.com/seasalt-ai/snowboy)\n\n####  New: build your own personal models (Ubuntu 16.04 and macOS)\n\n- Install dependencies\n\n```shell\nvirtualenv -p python2 venv/snowboy\nsource venv/snowboy/bin/activate\ncd examples/Python\npip install -r requirements.txt\n```\n\n代码经过我的魔改后\n\n![image-20210218215330306](https://cdn.jsdelivr.net/gh/zhouyuntao233/Picture_Bed/img/image-20210218215330306.png)\n\n![image-20210218215434563](https://cdn.jsdelivr.net/gh/zhouyuntao233/Picture_Bed/img/image-20210218215434563.png)\n\n\n\n- Try the trained personal model\n\n```shell\npython demo.py hotword.pmdl\n```\n\n\n\n### 语音助手\n\n[参考链接](https://www.passerma.com/article/54)\n\n\n\n![image-20210218215657605](https://cdn.jsdelivr.net/gh/zhouyuntao233/Picture_Bed/img/image-20210218215657605.png)","categories":["工具配置"]},{"title":"直播技术相关","url":"/2021/02/18/直播技术相关/","content":"\n\n\n**记录一下视频直播多端实现**\n\n<!--more--> \n\n### 树莓派推流\n\n树莓派推流方式\n\n##### 1.使用自带的raspivid\n\n```shell\nsudo raspivid -o - -t 0 -n -w 640 -h 360 -t 0 -a 12 -a 1024 -a \"PiCam %Y-%m-%d %X\" -fps 25|ffmpeg -i - -vcodec copy -an -f flv rtmp://81.70.192.71/dash/video\n```\n\n##### 2.Python 脚本推流\n\n```python\nimport subprocess as sp\nimport cv2\nrtmpUrl = \"rtmp://81.70.192.71:1935/dash/video\"\n\ncap = cv2.VideoCapture(0)\n\n# Get video information\nfps = int(cap.get(cv2.CAP_PROP_FPS))\nwidth = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))\nheight = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n\n# ffmpeg command\ncommand = ['ffmpeg',\n        '-y',\n        '-f', 'rawvideo',\n        '-vcodec','rawvideo',\n        '-pix_fmt', 'bgr24',\n        '-s', \"{}x{}\".format(width, height),\n        '-r', str(fps),\n        '-i', '-',\n        '-c:v', 'libx264',\n        '-pix_fmt', 'yuv420p',\n        '-preset', 'ultrafast',\n        '-f', 'flv', \n        rtmpUrl]\n\n# 管道配置\np = sp.Popen(command, stdin=sp.PIPE)\n        \n# read webcamera\nwhile(cap.isOpened()):\n    ret, frame = cap.read()\n    if not ret:\n        print(\"Opening camera is failed\")\n        break\n\n    p.stdin.write(frame.tobytes())\n```\n### 服务器端配置\n\n服务器端主要配置\n\n#### 编译安装nginx和nginx-rtmp模块\n\n```shell\ngit clone https://github.com/arut/nginx-rtmp-module.gitcd nginx-1.18.0/\ncd nginx-1.18.0/\nsudo ./configure --with-http_ssl_module --add-module=../nginx-rtmp-module\nsudo make \nsudo make install\n```\n\n#### nginx相关操作\n\n```shell\nsudo cp objs/nginx /usr/local/nginx/sbin/nginx # 涉及到添加模块如nginx配置ssl证书\nsudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\nsudo cp /usr/local/nginx/sbin/nginx /usr/local/bin/ #把nginx加入到环境变量里\nnginx            #第一次启动\nnginx -t        #检查配置文件是否正确\nnginx -s reload  #平滑重启，修改配置文件后，不断服务重启\nnginx -s stop    #停止服务\n```\n\n\n\n#### 配置nginx.conf\n\n```nginx\n#user  nobody;\nworker_processes  1;\n\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#pid        logs/nginx.pid;\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n    #                  '$status $body_bytes_sent \"$http_referer\" '\n    #                  '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    #access_log  logs/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n\n    #gzip  on;\n    server {\n        #SSL 访问端口号为 443\n        listen 443 ssl; \n    #填写绑定证书的域名\n        server_name hahayun.top; \n    #证书文件名称\n        ssl_certificate 1_hahayun.top_bundle.crt; \n    #私钥文件名称\n        ssl_certificate_key 2_hahayun.top.key; \n        ssl_session_timeout 5m;\n    #请按照以下协议配置\n        ssl_protocols TLSv1 TLSv1.1 TLSv1.2; \n    #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。\n        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; \n        ssl_prefer_server_ciphers on;\n        location / {\n        #网站主页路径。此路径仅供参考，具体请您按照实际目录操作。\n            root html; \n            index  index.html index.htm;\n        }\n    }\n\n    server {\n        listen       80;\n        server_name  localhost;\n\n        #charset koi8-r;\n        #access_log  logs/host.access.log  main;\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        #error_page  404              /404.html;\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n        \n        location /hls {\n            add_header Access-Control-Allow-Origin *;\n            types {\n                application/x-mpegURL;\n                video/mp2t ts;\n                }\n                root /usr/local/nginx/html/;\n                add_header Cache-Control no-cache;\n        }\n        location /dash {\n            add_header Access-Control-Allow-Origin *; #跨域配置\n            # Serve DASH fragments\n            root /usr/local/nginx/html/;\n            add_header Cache-Control no-cache;\n        }\n    \n\n        location /stat {\n            rtmp_stat all;\n            rtmp_stat_stylesheet stat.xsl;\n        }\n\n        location /stat.xsl {\n            root /usr/local/extend_module/nginx-rtmp-module/;\n        }\n    }\n\n}\n    # another virtual host using mix of IP-, name-, and port-based configuration\n    #\n    #server {\n    #    listen       8000;\n    #    listen       somename:8080;\n    #    server_name  somename  alias  another.alias;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n    # HTTPS server\n\nrtmp {\n    server {\n    listen 1935;\n    chunk_size 4000;\n    # hls配置    \n    # application live {\n    #     live on;\n    #     hls on;\n    #     hls_path /usr/local/nginx/html/hls;\n    #  }\n    # }\n    \n    # dash配置    \n    application dash {\n        live on;\n        dash on;\n        dash_path /usr/local/nginx/html/dash;\n        dash_playlist_length 10s;\n        dash_fragment 3s;   \n    }\n }\n}\n```\n\n### web端拉流\n\n#### 采用nodejs搭建web服务\n\n```javascript\nconst express = require('express');\nconst app=express()\nconst http=require('http').createServer(app);\nconst io=require('socket.io')(http)\nconst port = 3000\napp.use(\"/static\", express.static('static/'));\napp.get('/', (req, res) => {\n  res.sendFile(__dirname+'/static/index.html');\n  \n})\napp.get('/camera', (req, res) => {\n  res.sendFile(__dirname + '/static/camera.html');\n  })\n  \nio.on('connection',(socket)=>{\n  console.log('a user connected:'+socket.id);\n  socket.on('chat message', (msg) => {\n    console.log('message: ' + msg);\n  });\n\n})\n\nhttp.listen(port, () => {\n  console.log(`Example app listening at http://localhost:${port}`)\n})\n```\n\n\n\n#### 拉取hls流播放\n\n在网页body填入\n\n```html\n <video-js id=\"my_video_1\" class=\"vjs-default-skin\" controls preload=\"auto\" width=\"640\" height=\"268\">\n    <source src=\"http://81.70.192.71/hls/video.m3u8\" type=\"application/x-mpegURL\">\n  </video-js>\n  \n  <script src=\"https://unpkg.com/video.js/dist/video.js\"></script>\n  <script src=\"https://unpkg.com/@videojs/http-streaming/dist/videojs-http-streaming.js\"></script>\n  \n  <script>\n    var player = videojs('my_video_1');\n  </script>\n  \n```\n\n#### 拉取dash流播放\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=utf-8 />\n<title>videojs-contrib-hls embed</title>\n  \n  <!--\n\n  Uses the latest versions of video.js and videojs-http-streaming.\n\n  To use specific versions, please change the URLs to the form:\n\n  <link href=\"https://unpkg.com/video.js@6.7.1/dist/video-js.css\" rel=\"stylesheet\">\n  <script src=\"https://unpkg.com/video.js@6.7.1/dist/video.js\"></script>\n  <script src=\"https://unpkg.com/@videojs/http-streaming@0.9.0/dist/videojs-http-streaming.js\"></script>\n\n  -->\n\n  <link href=\"https://unpkg.com/video.js/dist/video-js.css\" rel=\"stylesheet\">\n</head>\n<body>\n  <h1>Camera Capture</h1>\n\n  <video id=example-video width=600 height=300 class=\"video-js vjs-default-skin\" controls></video>\n  <script src=\"https://cdn.bootcdn.net/ajax/libs/video.js/7.10.1/alt/video.core.min.js\"></script>\n\n  \n  <!-- Dash.js -->\n  <script src=\"https://cdn.bootcdn.net/ajax/libs/dashjs/3.2.0/dash.all.min.js\"></script>\n  \n  <!-- videojs-contrib-dash script -->\n  <script src=\"https://cdn.bootcdn.net/ajax/libs/videojs-contrib-dash/3.0.0/videojs-dash.min.js\"></script>\n  \n  <script>\n  var player = videojs('example-video');\n  \n  player.ready(function() {\n    player.src({\n      src: 'http://81.70.192.71/dash/video.mpd',\n      type: 'application/dash+xml'\n    });\n  \n    player.play();\n  });\n  </script>\n  \n</body>\n</html>\n```\n\n\n\n### 安卓端播放直播流\n\n安卓端采用Exoplayer播放流媒体\n\n[Exoplayer文档](https://exoplayer.dev/hello-world.html)\n\n![image-20210218083542404](https://cdn.jsdelivr.net/gh/zhouyuntao233/Picture_Bed/img/image-20210218083542404.png)\n\n```\n# 引入包\nimplementation 'com.google.android.exoplayer:exoplayer:2.13.1'\n```\n\n**activity_main.xml**\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\">\n\n    <com.google.android.exoplayer2.ui.PlayerView\n        android:id=\"@+id/video_view\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"/>\n</androidx.constraintlayout.widget.ConstraintLayout>\n```\n\n\n\n**MainActivity**\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        PlayerView playerView=findViewById(R.id.video_view);\n        // Create a data source factory.\n        DataSource.Factory dataSourceFactory = new DefaultHttpDataSource.Factory();\n        // Create a DASH media source pointing to a DASH manifest uri.\n        MediaSource mediaSource =\n                new DashMediaSource.Factory(dataSourceFactory)\n                        .createMediaSource(MediaItem.fromUri(\"http://81.70.192.71/dash/video.mpd\"));\n        // Create a player instance.\n        SimpleExoPlayer player = new SimpleExoPlayer.Builder(this).build();\n        // Set the media source to be played.\n        playerView.setPlayer(player);\n        player.setPlayWhenReady(true);\n        player.setMediaSource(mediaSource);\n        // Prepare the player.\n        player.prepare();\n    }\n}\n```","tags":["工具配置"]},{"title":"开发环境常用配置","url":"/2021/02/01/开发环境常用配置/","content":"\n### 整理一些常用环境配置\n\n<!--more--> \n\n### debian 系 apt换源\n\n```shell\nsudo  vim /etc/apt/sources.list \n```\n\n### PiP快速换源\n\n```shell\npip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple/\n```\n\n### Nodejs 换源\n\n```shell\nnpm config set registry https://registry.npm.taobao.org\n```\n\n\n\n","tags":["Python"],"categories":["工具配置"]},{"title":"操作系统复试相关问题","url":"/2021/01/26/操作系统复试相关问题/","content":"\n\n\n寒假在家，整理一些考研复试中有关操作系统的问题\n\n（根据王道论坛的资料整理）\n\n<!--more--> \n\n###  1.操作系统的几大功能是什么\n\n操作系统的功能包括处理器管理，存储器管理，设备管理，⽂件管理以及向⽤户提 供命令接⼝和程序接⼝。如下图所示\n\n![](https://cdn.jsdelivr.net/gh/zhouyuntao233/Picture_Bed/img/%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD.svg)\n\n### 2.【概述】硬实时和软实时的区别\n\n【追问了下使⽤什么调度算法可以实现】\n\n硬实时系统是某个动作必须绝对地在规定的时刻发生，比如飞行器的飞行自动控制系 统。\n\n软实时系统能接受偶尔违反时间规定且不会引起永久性的损害，比如飞机订票系统。\n\n### 3. 【概述】中断的处理过程\n\n#### a. 中断的作用 \n\n中断是多道程序得以实现的基础，进程之间的切换是通过中断来完成的。此外，为了提高处理机的利用率和实现CPU与I/O设备的并行执行，也必须要有中断的支 持。 \n\n#### b. 中断和陷入 \n\n中断：又叫外中断，是指CPU对I/O设备发来的中断信号的一种响应。CPU保护并 暂停当前进程，转而去处理引发中断的进程。执行完后，再返回到原进程，继续 执行。I/O设备可以是字符设（键盘），块设备（磁盘）或通信设备（网络） 等。 \n\n陷入：又叫内中断，陷入是由CPU进程内部事件引发的中断。其产生的原因往往 是由于进程本身出现运行时异常。 两者的区别仅仅是信号的来源不同。\n\n#### c. 中断向量表和中断优先级\n\n中断向量表：用于记录相应中断处理程序入口地址的映射表。表中有为中断类型 分配的中断号和相对应的中断处理程序的入口地址。当中断来临时，由中断控制 器确定中断号，再到表中寻找程序。 中断优先级：对于并发的中断请求，必须要给出合理的中断顺序，比如键盘中断 和磁盘中断谁更重要等，要给出解决中断的优先级。 \n\n#### d. 多中断的处理方式 \n\n试想一种情况：当处理机正在处理键盘引起的中端，此时又收到了高优先级的磁 盘中断，应该如何处理？ \n\n##### 硬件中断不可屏蔽\n\ni. 屏蔽（禁止）中断：对于新来的中断，在当前中断未完成之前，对于其他中断 不予理睬，直到当前处理完。采用先来先服务的方式。 \n\nii. 嵌套中断：中断的中断。中断处理程序也是进程，当更高优先级的中断处理程 序到来时，可以剥夺当前中断处理进程的处理机，及中断的中断。此种情况 下，CPU总是优先响应更高优先级的中断请求。 \n\n#### e. 中断处理程序的处理过程 \n\n不可屏蔽中断：中断隐指令（关中断->保存断点->中断服务程序寻址）->保存现 场->执行中断服务程序->恢复现场->开中断->中断返回 可屏蔽中断：中断隐指令（关中断->保存断点->中断服务程序寻址）->开中断- >保存现场和屏蔽字->关中断->执行中断服务程序->恢复现场和屏蔽字->开中 断->中断返回 \n\ni. 测定是否有未响应的中断信号。当设备完成I/O后，设备控制器会向处理机发 送中断信号，告诉I/O完成。之后要测试在中断请求队列中是否有未响应的请 求。 \n\nii. 保护被中断进程的CPU环境。保存现场，将进程的CPU信息全部载入进程PCB 中（堆栈区），然后切换进程。 \n\niii. 转入相应的设备处理程序。根据中断号找到相应程序的入口，交给设备驱动程 序。 \n\niv. 中断处理。检测设备控制器中相应设备的状态（正常、异常），并给予相应的 解决。 \n\nv. 恢复CPU现场并退出中断。如果是屏蔽中断，返回被中断进程；嵌套中断，检 查优先级队列，根据是否有更高优先级中断请求，选择返回原中断还是处理更 高优先级中断； \n\nvi. 检测中断是否处理正确，向上层软件确定结果，报告等后续操作。","tags":["考研"],"categories":["操作系统"]},{"title":"2021的一点祝福","url":"/2021/01/24/zhouyuntao的一点随想/","content":"\n### 2020年过去了🎈\n\n😃 新的一年\n带给你一如既往的祝愿\n有盛天共赏\n有温汤可享\n有人爱，有爱人","tags":["新年祝福"],"categories":["闲谈杂记"]},{"title":"树莓派的装系统","url":"/2020/12/31/树莓派的装系统/","content":"2020的最后一天啦\n昨天下午拿到了树莓派4B 2G版本\n<!--more--> \n### 1、烧录SD卡\n这里推荐树莓派官方的烧写工具\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201231102138625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg4MzEy,size_16,color_FFFFFF,t_70)\n官网好像就有下，先将系统下载下来，再选择将系统烧录到SD卡。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201231102257439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg4MzEy,size_16,color_FFFFFF,t_70)\n烧录玩镜像后，弹出U盘，再将U盘插回到电脑中，会显示两个盘。\n\n#### ubuntu系统\n\n修改Boot那个盘中的network-config文件\n\n [ubuntu官网的指导](https://ubuntu.com/tutorials/how-to-install-ubuntu-on-your-raspberry-pi#1-overview).\n 改成这样的就好了![在这里插入图片描述](https://img-blog.csdnimg.cn/2020123110323522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg4MzEy,size_16,color_FFFFFF,t_70)\n之后拔出SD卡，插到树莓派中点亮开机\n\n#### 树莓派RaspberryOS\n\n如果是树莓派官方系统的话，则添加以下两个文件\n\n**ssh**\n\n**wpa_supplicant.conf**\n\n```shell\nctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\nupdate_config=1\ncountry=CN\n \nnetwork={\n\tssid=\"1234567\"    #WiFi账号\n\tpsk=\"123456789\"   #WiFi密码\n}\n```\n\n\n\n\n\n### 2.SSH连接树莓派\n登录路由器管理界面，查看连接的设备\n找到树莓派的**IP** 地址，然后用SSH连接上（ubuntu系统默认密码为ubuntu）\n### 3. 修改时间\n可以先用date 命令查看时间\n3.1 修改时区\n```shell\nsudo tzselect\nsudo cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n```\n3.2 安装ntpdate\n```shell\nsudo apt install ntpdate\nsudo ntpdate ntp.api.bz //同步时间\n```\n一般来说时间同步就完成了，可能还需要安装\n```shell\nsudo apt install ntp\n```\n[参照知乎某大佬的解决方案](https://zhuanlan.zhihu.com/p/190150063).\n### 4.修改国内源\nubuntu的源位于\n```shell\n/etc/apt/sources.list\n```\n替换成清华源(也可以替换成中科大源，阿里云等但要注意是ubuntu-ports的源)\n```shell\nsudo sed -i \"s/ports.ubuntu.com/mirrors.tuna.tsinghua.edu.cn/n\" sources.list\nsudo sed -i \"s/http/https/n\" sources.lsit\n```\n更新完后\n```shell\nsudo apt update\n```\n\n### 5. raspberryPi的国内源\n\n[清华镜像源](https://mirror.tuna.tsinghua.edu.cn/help/raspbian/)","tags":["Linux"],"categories":["工具配置"]},{"title":"排序算法总结","url":"/2020/12/01/排序算法总结/","content":"### 整理一些常见的排序算法\n\n<!--more--> \n\n### 插入排序\n\n直接插入排序，折半插入排序，希尔排序\n### 交换排序\n冒泡排序，堆排序\n### 选择排序\n简单选择排序，快速排序\n**此外：** 归并排序，基数排序\n<!--more--> \nday11/29 马上就要考试了，捋了捋算法题要用到的代码\n408常考算法题主要集中在线性表上，其中对于顺序表主要考察对数组的操作，对于链式表主要考察对链表的操作。\n\n对于数组来说，很多题目都会用到排序算法，这里记一下排序算法中性能最优秀的**快速排序算法**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201129162055201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg4MzEy,size_16,color_FFFFFF,t_70)\n\n**归并排序也很重要**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020112916573096.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg4MzEy,size_16,color_FFFFFF,t_70)\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200211183023586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg4MzEy,size_16,color_FFFFFF,t_70)\n","tags":["排序"],"categories":["数据结构/算法"]},{"title":"Git的常规操作","url":"/2019/10/24/Git的常规操作/","content":"\n关于git的学习先推荐一个网站\n[git学习操作网站](https://learngitbranching.js.org/)\n网站是用js做的，很有意思。\n## git和github\ngit和github的安装和使用我就不说了，百度什么的都可学到\n<!--more--> \n### git 初始化\n这里盗图一张\n![git初始化](https://img-blog.csdnimg.cn/20191018143945774.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg4MzEy,size_16,color_FFFFFF,t_70)\n```shell\ngit init//git初始化\ngit remote add origin https://github.com/XXX/XXXXX.git \n//添加远程仓库的地址\n```\n我使用的是visual studio内置的git,\n在项目中添加到源代码管理后，然后同步\n![VS2017](https://img-blog.csdnimg.cn/20191018140205917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg4MzEy,size_16,color_FFFFFF,t_70)\n选择Sync同步push后一般会报两个错误\n一个是\nrejected Updates were rejected because the remote contains work that you do not have locally\n意思是更新被拒绝,远程仓库有的文件你本地没有\n那就git pull吧\n### 这里解释一下git pull\n```shell\ngit pull origin 分支名称\n```\n``git pull`` 虽是一条语句 作用是将拉取的分支与当前分支合并\n却是 git fetch 和 git merge两条语句\n``git fetch`` 会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看\n**但是** 并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作\n``git merge`` ：和并分支\n**注意**\n1.每次使用该命令前，需要保证本地工作区是没有任何修改代码的，也就是说需要将本地工作区编辑过的文件添加到暂存区（``git add .``），或提交到本地仓库中(``git commit``)，才可以使用该命令拉取指定分支的代码合并到当前分支中\n2.每次在操作完``git commit``命令后，必须拉取一下master分支代码，保持本地正在开发功能逻辑的代码分支代码是最新的，避免后续在提交时冲突过多或覆盖掉其他人的代码的问题出现\n![git](https://img-blog.csdnimg.cn/20191018141222881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg4MzEy,size_16,color_FFFFFF,t_70)\n虽然执行了``git pull``, 但是没有关联到远端分支， 所以并没有获取远端分支的最新版\n讲道理``git pull``后应该同步了吧，\n然后执行``git push`` 说**The current branch master has no upstream branch**\n意思是本地分支没有对应到远端的分支\n好，我们来关联远端分支\n```shell\ngit branch --set-upstream-to=origin/master\n```\n然后执行``git push``\n![报错图](https://img-blog.csdnimg.cn/20191018142352254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg4MzEy,size_16,color_FFFFFF,t_70)\n本地分支要比远程分支落后\n忘记执行``git pull``了\n再次报错\nf**atal: refusing to merge unrelated histories**\n意思是拉取失败， 拒绝merge 不相关的历史， 因为本地也有提交\n最后使用大杀招\n```shell\ngit pull origin master --allow-unrelated-histories \n//允许不相干的历史\n//或者也可以使用以下的命令\ngit push -u origin master -f\n```\n成功push了\n","tags":["Git"],"categories":["工具配置"]},{"title":"C++ STL 常用操作","url":"/2019/02/19/C-STL-常用操作/","content":"\n\n\n简单记录一下C++ STL库的一些常用操作\n\n<!--more--> \n\n```c++\nvector, 变长数组，倍增的思想\n    size()  返回元素个数\n    empty()  返回是否为空\n    clear()  清空\n    front()/back()\n    push_back()/pop_back()\n    begin()/end()\n    []\n    支持比较运算，按字典序\n\npair<int, int>\n    first, 第一个元素\n    second, 第二个元素\n    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）\n\nstring，字符串\n    size()/length()  返回字符串长度\n    empty()\n    clear()\n    substr(起始下标，(子串长度))  返回子串\n    c_str()  返回字符串所在字符数组的起始地址\n\nqueue, 队列\n    size()\n    empty()\n    push()  向队尾插入一个元素\n    front()  返回队头元素\n    back()  返回队尾元素\n    pop()  弹出队头元素\n\npriority_queue, 优先队列，默认是大根堆\n    push()  插入一个元素\n    top()  返回堆顶元素\n    pop()  弹出堆顶元素\n    定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q;\n\nstack, 栈\n    size()\n    empty()\n    push()  向栈顶插入一个元素\n    top()  返回栈顶元素\n    pop()  弹出栈顶元素\n\ndeque, 双端队列\n    size()\n    empty()\n    clear()\n    front()/back()\n    push_back()/pop_back()\n    push_front()/pop_front()\n    begin()/end()\n    []\n\nset, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列\n    size()\n    empty()\n    clear()\n    begin()/end()\n    ++, -- 返回前驱和后继，时间复杂度 O(logn)\n\n    set/multiset\n        insert()  插入一个数\n        find()  查找一个数\n        count()  返回某一个数的个数\n        erase()\n            (1) 输入是一个数x，删除所有x   O(k + logn)\n            (2) 输入一个迭代器，删除这个迭代器\n        lower_bound()/upper_bound()\n            lower_bound(x)  返回大于等于x的最小的数的迭代器\n            upper_bound(x)  返回大于x的最小的数的迭代器\n    map/multimap\n        insert()  插入的数是一个pair\n        erase()  输入的参数是pair或者迭代器\n        find()\n        []  注意multimap不支持此操作。 时间复杂度是 O(logn)\n        lower_bound()/upper_bound()\n\nunordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表\n    和上面类似，增删改查的时间复杂度是 O(1)\n    不支持 lower_bound()/upper_bound()， 迭代器的++，--\n\nbitset, 圧位\n    bitset<10000> s;\n    ~, &, |, ^\n    >>, <<\n    ==, !=\n    []\n\n    count()  返回有多少个1\n\n    any()  判断是否至少有一个1\n    none()  判断是否全为0\n\n    set()  把所有位置成1\n    set(k, v)  将第k位变成v\n    reset()  把所有位变成0\n    flip()  等价于~\n    flip(k) 把第k位取反\n```\n\n","tags":["C++"],"categories":["数据结构/算法"]},{"title":"ubuntu编译内核 添加系统调用","url":"/2019/01/24/ubuntu编译内核-添加系统调用/","content":"\nLinux 编译内核那点事\n花了几天填了一下坑\n大概步骤就是下载内核，编译内核。其实也没什么复杂的就是一些细节要注意一下。\n<!--more--> \n内核要从官网下载 **https://www.kernel.org/**\n选择tarball 下载项即可。\n下载后，进入到有下载项的那个目录\n打开终端 **sudo mv linux-4.4.179.tar.xz /usr/src** \n之后进入/usr/src\n\n```shell\ncd /usr/src\nsudo tar -xvf /usr/src/linux-4.16.10.tar.bz2\n```\n\n可能你会先解压再移动到/usr/src文件夹下，这样的话可能有些文件会在移动中丢失掉了，导致编译是缺少文件\n所以最合理的是先将压缩包移动到/usr/src文件夹下，再进行解压。\n接下来进入\n\n```shell\ncd /usr/src/linux-4.4.1179/kernel\nsudo vim sys.c\n```\n添加系统调用的函数定义\n```c\nSYSCALL_DEFINE1(mycall, struct timeval *, tv) {//系统函数定义格式 mycall为添加的调用函数名，struct timeval *, tv为参数为结构体指针\nstruct timeval ktv;\ndo_gettimeofday(&ktv);//可能会写gettimeofday()，笔者就因为写这个函数编译了好几次都没有通过，报错为缺少头文件,但作为系统函数，只能写do_gettimeofday().\nif(copy_to_user(tv, &ktv, sizeof(ktv) ) ) {//将核心态的结果拷贝到用户态\nreturn -EFAULT;\n}\nreturn 0;\n}\n```\n函数定义写好后，就要在头文件中添加声明\n\n```shell\ncd /usr/src/linux-4.4.179/arch/x86/include/asm/\nsudo vim syscalls.h\n在末尾插入asmlinkage long sys_mycall(strruct timeval *tv);//声明要和函数定义中保持一致函数名，参数等\n```\n加一个系统调用的id\n\n```shell\ncd/usr/src/linux-4.4.179/arch/x86/entry/syscalls//进入/usr/src/linux-4.16.10/arch/x86/syscalls目录\n\nvim syscall_64.tbl//打开文件syscall_64.tbl（该文件有一个系统调用列表，最前面的属性是id)\n```\n\n在里面添加自己的系统调用号（326  common  mycall           sys_mycall）//326为当前调用号加一得来的\n\n最后保存退出\n**最后一步**\n配置内核\ncd  /usr/src/linux-4.4.179\n\n编译内核和安装内核.\n\n依次输入这四条语句\n```shell\nsudo make mrproper\nsudo make clean\nsudo make menuconfi//先点save 再点exit\n```\n```shell\nsudo make -j8//可以使用多线程编译 j8为8线程，多线程不好的地方就是出现错误不会停下来，下一个线程就切过去了，所以为了稳妥还是老老实实 sudo make 吧\n```\n如果运气好，没报错的话，接下来进行模块安装\n```shell\nsudo make modules_install  \nsudo install//将内核安装到系统中\n```\n\n安装好后重启电脑，开机选项中选择高级选项\n选择你装好的内核版本\n下面进行验证添加的系统调用函数\n编写一个c文件\n\n```c\n#define _GNU_SOURCE\n#include <unistd.h>\n#include <sys/time.h>\n#include <sys/syscall.h>\n#include <stdio.h>\n#define __NR_mycall 333 //系统调用号\n\nint main() {\n\n    struct timeval gettime;\n    struct timeval mycalltime;\n    gettimeofday(&gettime, NULL);\n    syscall(__NR_mycall, &mycalltime);\n    printf(\"gettimeofday:%ld %ld \\n\", gettime.tv_sec, gettime.tv_usec);\n    printf(\"mycall : %ld %ld \\n\", mycalltime.tv_sec, mycalltime.tv_usec);\n    return 0;\n}\n```\n如何结果相同则证明成功了。\n\n","tags":["Linux"],"categories":["操作系统"]}]